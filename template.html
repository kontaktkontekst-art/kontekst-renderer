<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <style>
    html, body { margin:0; padding:0; }
    body { background:#fff; }

    #canvas {
      position: relative;
      width: 1080px;
      height: 1350px;
      background: #F6F3EE;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    .bg {
      position:absolute;
      inset:0;
      background-size:cover;
      background-position:center;
      filter: brightness(0.6);
    }

    .content {
      position:absolute;
      inset:0;
      padding:96px 84px;
      display:flex;
      flex-direction:column;
      justify-content:flex-start;
    }

    h1 {
      font-size:84px;
      line-height:92px;
      margin:0;
      color:#111;
      max-width:900px;
    }

    .footer {
      position:absolute;
      bottom:40px;
      left:84px;
      right:84px;
      display:flex;
      justify-content:space-between;
      font-size:22px;
      color:#111;
    }
  </style>
</head>
<body>
  <div id="canvas">
    <div id="bg" class="bg"></div>

    <div class="content">
      <h1 id="headline"></h1>
    </div>

    <div class="footer">
      <div id="brand"></div>
      <div id="counter"></div>
    </div>
  </div>

  <script>
    window.__RENDERED__ = false;
    window.__RENDER_ERROR__ = "";

    function readRenderRequest() {
      const el = document.getElementById("__RR__");
      if (!el) return null;
      try { return JSON.parse(el.textContent || ""); }
      catch (e) { console.error("Failed to parse __RR__ JSON", e); return null; }
    }

    function preloadImage(url, timeoutMs = 6000) {
      return new Promise((resolve) => {
        const img = new Image();
        let done = false;

        const finish = (status) => {
          if (done) return;
          done = true;
          resolve(status);
        };

        const t = setTimeout(() => finish("timeout"), timeoutMs);

        img.onload = () => { clearTimeout(t); finish("loaded"); };
        img.onerror = () => { clearTimeout(t); finish("error"); };
        img.src = url;
      });
    }

    async function fontsReady(timeoutMs = 2000) {
      try {
        if (!document.fonts?.ready) return "no-font-api";
        return await Promise.race([
          document.fonts.ready.then(() => "ready"),
          new Promise((r) => setTimeout(() => r("timeout"), timeoutMs))
        ]);
      } catch {
        return "error";
      }
    }

    window.addEventListener("DOMContentLoaded", async () => {
      try {
        const rr = readRenderRequest();
        if (!rr) {
          console.error("Missing/invalid RenderRequest (__RR__)");
          window.__RENDER_ERROR__ = "Missing/invalid RenderRequest (__RR__)";
          window.__RENDERED__ = true;
          return;
        }

        // teksty
        document.getElementById("headline").textContent = rr.slots_fill?.headline || "";
        document.getElementById("brand").textContent = rr.brand_lockup?.handle_text || "";
        document.getElementById("counter").textContent = `${rr.slide}/${rr.total}`;

        // tło: najpierw preload, potem ustaw background-image
        const bgUrl = rr.slots_fill?.background_image?.url;
        if (bgUrl) {
          const status = await preloadImage(bgUrl, 6000);
          if (status === "loaded") {
            document.getElementById("bg").style.backgroundImage = `url("${bgUrl}")`;
          } else {
            console.warn("Background not loaded:", status, bgUrl);
            // Nie wywalamy renderu — ale przynajmniej mamy deterministykę
          }
        }

        // fonty best-effort
        await fontsReady(2000);

        window.__RENDERED__ = true;
      } catch (err) {
        console.error("Template exception", err);
        window.__RENDER_ERROR__ = String(err?.message || err);
        window.__RENDERED__ = true;
      }
    });
  </script>
</body>
</html>
